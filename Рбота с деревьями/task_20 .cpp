// ƒано дерево. ќпределить высоту узла X
#include<iostream>
#include <string>

using namespace std;

struct tree { // структура дерева
	int dual; // значени€ узла
	tree* right; // правый узел
	tree* left; // левый узел
};

tree* node(int x) { // функци€ создание узла 
	tree* n = new tree; // выделение пам€ти
	n->dual = x; // значени€ узла х
	n->left = n->right = NULL; // левый и правый узел ноль
	return n; // возвращение готового узла
}

void create(tree*& tr, int n) { //функци€ создание идеально сбалансированного дерева 
	int x; // объ€вление переменной 
	if (n > 0) { // пока n больше нул€ 
		cout << "Ёлемент:  "; // вывод на экран
		cin >> x; // ввод 
		tr = node(x); // создание узла
		int nl = n / 2; // нахождение кол-ва элементов в левой ветке
		int nr = n - nl - 1; // нахождение кол-ва элементов в правой ветке
		create(tr->left, nl); // рекурсивный вызов дл€ левой ветки
		create(tr->right, nr); // рекурсивный вызов дл€ левой правой
	}
}

void preorder(tree* tr) { // функци€ пр€мого обхода
	if (tr) { // если tr не ноль
		cout << tr->dual << " "; // вывод значени€
		preorder(tr->left);  // рекурсивный вызов по левой ветке
		preorder(tr->right); // рекурсивный вызов по правой ветке
	}
}

void find(tree* tr, int x, tree*& res) { // функци€ поиска 
	 if (tr) { // если узел не ноль
		 if (tr-> dual == x) { // если значение узла соответствует искомому элементу 
			 res = tr; // то элемент найден 
		}
		else { // иначе 
			 find(tr->left, x, res); // рекурсивный вызов функции дл€ левой ветки 
			 find(tr->right, x, res); // рекурсивный вызов функции дл€ правой ветки 
		}
	}
}

int hight(tree* tr){ // функци€ нахождени€ высоты дерева
	int l, r, h = 0; // объ€вление переменных
	if (tr){ // ≈сли узел не ноль
		l = hight(tr->left); // рекурсивный вызов функции дл€ левой ветки
		r = hight(tr->right); // рекурсивный вызов функции дл€ правой ветки
		h = ((l > r) ? l : r) + 1; // если l > r, то l, иначе r , а потом увеличение на 1
	}
	return h; // возврат найденной высоты
}

int main() {
	setlocale(LC_ALL, "RUS"); // подключение русской раскладки
	int n, x; // объ€вление переменной 
	cout << "n = "; // вывод на экран
	cin >> n; // ввод n
	cout << "x = "; // вывод на экран
	cin >> x; // ввод x
	tree* tr = NULL; // объ€вление дерева 
	create(tr, n); // вызов функции заполнени€ дерева
	preorder(tr);  // пр€мой обход
	cout << endl;
	tree* ptr = NULL; // объ€вление дополнительного узла
    find(tr, x, ptr); // функци€ поиска нужного элемента
	cout << "¬ысота = " << hight(ptr) - 1 << endl; // вывод значени€
	return 0;
}